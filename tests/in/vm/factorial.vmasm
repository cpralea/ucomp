; 
; Compute 5! using
;
;     factorial(n) {
;         if (n <= 1)
;             return 1;
;         return n * factorial(n-1);
;     }
; 
; Intentionally written as if generated by a compiler.
; 



main:
    ; push 5 on stack
    mov r0, 5
    push r0

    ; compute 5!
    call factorial

    ; copy 5! into r0
    pop r0
    
    ; exit VM
    mov r0, 0
    push r0
    call $sys_enter



factorial:
    ; r0 = address of argument list and eventual return value
    mov r0, sp

    ; r1 = n
    add r0, 4
    load r1, [r0]

    ; if n <= 1 then
    cmp r1, 1
    jmpgt .l1

    ; return 1
    mov r1, 1
    store [r0], r1
    ret

    ; else
.l1:
    ; r2 = n - 1
    mov r2, r1
    sub r2, 1

    ; save state
    push r0
    push r1

    ; push argument on stack: n - 1
    push r2

    ; compute (n - 1)!
    call factorial

    ; r2 = (n - 1)!
    pop r2

    ; restore state
    pop r1
    pop r0

    ; save state
    push r0

    ; push arguments on stack: n, (n - 1)!
    push r1
    push r2

    ; compute n * (n - 1)!
    call multiply

    ; r1 = n!
    pop r1

    ; restore state
    pop r0

    ; put the return address on top of the return value
    sub r0, 4
    load r2, [r0]
    add r0, 0
    store [r0], r2
    add r0, 4

    ; return n!
    store [r0], r1
    ret



multiply:
    ; r0 = address of argument list and eventual return value
    mov r0, sp

    ; r3 = b
    add r0, 4
    load r3, [r0]

    ; r2 = a
    add r0, 4
    load r2, [r0]

    ; r1 = product = 0
    mov r1, 0

.l1:
    ; if b == 0 then return
    cmp r3, 0
    jmpz .l2

    ; else product += a
    add r1, r2

    ; b -= 1
    sub r3, 1

    ; loop
    jmp .l1

.l2:
    ; put the return address on top of the return value
    sub r0, 8
    load r2, [r0]
    add r0, 4
    store [r0], r2
    add r0, 4

    ; return product
    store [r0], r1
    ret
